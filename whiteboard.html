<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Whiteboard ‚Äî Draw ‚Ä¢ Pan/Zoom ‚Ä¢ Import/Export</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net">
<style>
  :root{
    --bg:#0b0f14; --panel:#111a25; --panel2:#0e1722; --text:#eaf0f7; --muted:#92a4bf; --border:#263446; --accent:#75c6ff;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:linear-gradient(180deg,#0b0f14,#0f1520);color:var(--text);font:15px/1.5 system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif}
  header{max-width:1200px;margin:18px auto 0;padding:0 16px}
  h1{margin:0 0 6px;font-weight:800;font-size:24px}
  .sub{margin:0 0 14px;color:var(--muted)}
  main{max-width:1200px;margin:0 auto 18px;padding:0 16px}

  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:10px 0 12px}
  button,label.btn{padding:8px 12px;border-radius:10px;border:1px solid var(--border);background:#132033;color:var(--text);cursor:pointer;transition:.15s transform ease;display:inline-flex;gap:8px;align-items:center}
  button:hover,label.btn:hover{transform:translateY(-1px)}
  .primary{background:linear-gradient(180deg,#24466d,#1b3553);border-color:#33537b}
  .ghost{background:transparent}
  .warn{background:linear-gradient(180deg,#5c3d16,#3f2a0e);border-color:#6a4b22}
  .seg{display:inline-flex;border:1px solid var(--border);border-radius:10px;overflow:hidden}
  .seg button{border:0;border-right:1px solid var(--border);background:#0f1827}
  .seg button.active{background:linear-gradient(180deg,#24466d,#1b3553)}
  .seg button:last-child{border-right:0}
  input[type="file"]{display:none}
  .tiny{font-size:12px;color:var(--muted)}

  .boardWrap{background:#0a1420;border:1px solid var(--border);border-radius:14px;box-shadow:0 10px 22px rgba(0,0,0,.35);position:relative;overflow:hidden}
  canvas{display:block;width:100%;height:70vh;background:#0b1625;cursor:crosshair}
  .status{position:absolute;bottom:8px;right:12px;background:rgba(0,0,0,.45);border:1px solid #20344f;color:#cfe0ff;padding:5px 8px;border-radius:8px;font-size:12px}
  .floatingInput{position:absolute;min-width:180px;padding:4px 6px;border-radius:8px;border:1px solid var(--border);background:#0f1722;color:#eaf0f7}
</style>
</head>
<body>
<header>
  <h1>Whiteboard</h1>
  <p class="sub">Freehand drawing, shapes, text, pan/zoom. Import/Export to PNG, SVG, or JSON. Everything stays in your browser.</p>
</header>

<main>
  <div class="toolbar">
    <span class="tiny">Tools:</span>
    <span class="seg" id="toolSeg">
      <button type="button" data-tool="brush" class="active">‚úèÔ∏è Brush (B)</button>
      <button type="button" data-tool="highlighter">üñç Highlighter (H)</button>
      <button type="button" data-tool="eraser">üßΩ Eraser (E)</button>
      <button type="button" data-tool="line">Ôºè Line (L)</button>
      <button type="button" data-tool="rect">‚ñ≠ Rect (R)</button>
      <button type="button" data-tool="text">üî§ Text (T)</button>
      <button type="button" data-tool="pan">‚úã Pan (Space)</button>
    </span>
    <span class="tiny">Color</span>
    <input type="color" id="color" value="#ffde59" />
    <span class="tiny">Size</span>
    <input type="range" id="size" min="1" max="48" value="6" />
    <span class="tiny">Opacity</span>
    <input type="range" id="opacity" min="0.05" max="1" step="0.05" value="1" />
    <span class="tiny">Zoom</span>
    <input type="range" id="zoom" min="0.5" max="3" step="0.05" value="1" />
    <button id="resetView" type="button">Reset view</button>
    <span class="tiny">BG</span>
    <select id="bg">
      <option value="grid" selected>Grid</option>
      <option value="dots">Dots</option>
      <option value="plain">Plain</option>
      <option value="lined">Lined</option>
    </select>
  </div>

  <div class="toolbar">
    <button id="undoBtn" type="button">Undo (Ctrl/Cmd+Z)</button>
    <button id="redoBtn" type="button">Redo (Ctrl/Cmd+Y)</button>
    <span class="tiny">|</span>
    <button id="exportPNG" type="button" class="primary">Export PNG</button>
    <button id="exportSVG" type="button">Export SVG</button>
    <button id="exportJSON" type="button">Export JSON</button>
    <label for="importJSON" class="btn">Import JSON<input id="importJSON" type="file" accept="application/json"></label>
    <span class="tiny">|</span>
    <label for="importIMG" class="btn">Insert Image<input id="importIMG" type="file" accept="image/*"></label>
    <button id="clearBoard" type="button" class="warn">Clear</button>
    <span class="tiny" id="saveState">Saved</span>
  </div>

  <div class="boardWrap">
    <canvas id="c"></canvas>
    <div class="status" id="status">Brush ‚Ä¢ size 6 ‚Ä¢ 100% ‚Ä¢ zoom 1.00√ó</div>
  </div>
</main>

<script>
// ====== Utilities ======
const $ = sel => document.querySelector(sel);
const uid = p => `${p}_${Math.random().toString(36).slice(2,9)}`;
function deepClone(o){ return JSON.parse(JSON.stringify(o)); }

// ====== Canvas & Viewport ======
const canvas = $('#c');
const ctx = canvas.getContext('2d');
const view = { x:0, y:0, scale:1 };
function resize(){
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = Math.max(800, rect.width);
  canvas.height = Math.max(500, rect.height);
  draw();
}
window.addEventListener('resize', resize);

function worldToScreen(x,y){ return { x:(x - view.x)*view.scale, y:(y - view.y)*view.scale }; }
function screenToWorld(x,y){ return { x: x/view.scale + view.x, y: y/view.scale + view.y }; }

// ====== State ======
const LS_KEY = 'whiteboard_state_v1';
let board = loadState() || { bg:'grid', elements:[] };
let history = { past:[], future:[] };

function save(){ localStorage.setItem(LS_KEY, JSON.stringify(board)); $('#saveState').textContent = 'Saved'; }
function loadState(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)||''); }catch(e){ return null; } }
function pushHistory(){ history.past.push(JSON.stringify(board)); history.future.length=0; save(); }
function undo(){ if(!history.past.length) return; history.future.push(JSON.stringify(board)); board = JSON.parse(history.past.pop()); save(); draw(); }
function redo(){ if(!history.future.length) return; history.past.push(JSON.stringify(board)); board = JSON.parse(history.future.pop()); save(); draw(); }

// ====== Tools ======
let tool = 'brush';
let color = $('#color').value; let size = +$('#size').value; let opacity = +$('#opacity').value;
let drawing = false; let current = null; let panActive = false; let panStart = {x:0,y:0, vx:0, vy:0};

function setTool(t){ tool=t; document.querySelectorAll('#toolSeg button').forEach(b=>b.classList.toggle('active', b.dataset.tool===t)); updateStatus(); }

// ====== Drawing Primitives ======
function drawGrid(){
  const spacing = 50; const s = view.scale; const w = canvas.width; const h = canvas.height;
  ctx.save();
  ctx.clearRect(0,0,w,h);
  // bg fill
  ctx.fillStyle = '#0b1625'; ctx.fillRect(0,0,w,h);
  // transform lines to screen space
  const startX = Math.floor(view.x/spacing)*spacing; const endX = Math.ceil((view.x + w/s)/spacing)*spacing;
  const startY = Math.floor(view.y/spacing)*spacing; const endY = Math.ceil((view.y + h/s)/spacing)*spacing;
  if(board.bg==='grid' || board.bg==='lined' || board.bg==='dots'){
    ctx.strokeStyle = 'rgba(255,255,255,0.07)'; ctx.lineWidth = 1; ctx.beginPath();
    if(board.bg!=='lined'){
      for(let x=startX; x<=endX; x+=spacing){ const p1=worldToScreen(x,startY), p2=worldToScreen(x,endY); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x,p2.y); }
    }
    for(let y=startY; y<=endY; y+=spacing){ const p1=worldToScreen(startX,y), p2=worldToScreen(endX,y); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x,p2.y); }
    ctx.stroke();
    if(board.bg==='dots'){
      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      for(let x=startX; x<=endX; x+=spacing){ for(let y=startY; y<=endY; y+=spacing){ const p=worldToScreen(x,y); ctx.fillRect(p.x-0.75,p.y-0.75,1.5,1.5);} }
    }
  }
  ctx.restore();
}

function renderElement(el){
  if(el.type==='stroke' || el.type==='highlight' || el.type==='eraser'){
    ctx.save();
    ctx.globalAlpha = (el.type==='highlight') ? (el.opacity||0.3) : (el.opacity||1);
    if(el.type==='eraser') ctx.globalCompositeOperation = 'destination-out';
    ctx.lineCap = 'round'; ctx.lineJoin='round';
    ctx.lineWidth = el.size * view.scale; // size independent of zoom
    ctx.strokeStyle = el.color || '#fff';
    ctx.beginPath();
    for(let i=0;i<el.points.length;i++){
      const p = worldToScreen(el.points[i].x, el.points[i].y);
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.stroke();
    ctx.restore();
  }
  if(el.type==='line' || el.type==='rect'){
    ctx.save(); ctx.globalAlpha = el.opacity||1; ctx.lineWidth = el.size * view.scale; ctx.strokeStyle = el.color||'#fff';
    const p1=worldToScreen(el.x1,el.y1), p2=worldToScreen(el.x2,el.y2);
    if(el.type==='line'){
      ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
    }else{
      const x=Math.min(p1.x,p2.x), y=Math.min(p1.y,p2.y), w=Math.abs(p2.x-p1.x), h=Math.abs(p2.y-p1.y);
      if(el.fill) { ctx.fillStyle = el.fill; ctx.globalAlpha = 0.15; ctx.fillRect(x,y,w,h); ctx.globalAlpha = el.opacity||1; }
      ctx.strokeRect(x,y,w,h);
    }
    ctx.restore();
  }
  if(el.type==='text'){
    ctx.save(); ctx.globalAlpha = el.opacity||1; ctx.fillStyle = el.color||'#fff';
    const p = worldToScreen(el.x,el.y); ctx.font = `${el.size||22}px Inter, system-ui, sans-serif`;
    ctx.textBaseline = 'top';
    const lines = (el.text||'').split(/\n/);
    for(let i=0;i<lines.length;i++){ ctx.fillText(lines[i], p.x, p.y + i*(el.size*1.3)); }
    ctx.restore();
  }
  if(el.type==='image'){
    const p = worldToScreen(el.x,el.y); const s = worldToScreen(el.x+el.w, el.y+el.h);
    const w = s.x - p.x; const h = s.y - p.y; const img = ensureImage(el);
    if(img) ctx.drawImage(img, p.x, p.y, w, h);
  }
}

const imageCache = new Map();
function ensureImage(el){
  if(!el.dataURL) return null; if(imageCache.has(el.id)) return imageCache.get(el.id);
  const img = new Image(); img.onload = ()=> draw(); img.src = el.dataURL; imageCache.set(el.id,img); return img;
}

function draw(){
  drawGrid();
  for(const el of board.elements){ renderElement(el); }
  updateStatus();
}

// ====== Pointer handling ======
let spaceDown = false; // pan modifier
canvas.addEventListener('pointerdown', e=>{
  canvas.setPointerCapture(e.pointerId);
  const pt = screenToWorld(e.offsetX, e.offsetY);
  if(tool==='pan' || spaceDown){
    panActive = true; panStart = { x:e.clientX, y:e.clientY, vx:view.x, vy:view.y };
    return;
  }
  if(tool==='brush' || tool==='highlighter' || tool==='eraser'){
    current = { id:uid('st'), type: tool==='brush'?'stroke':tool, points:[pt], color, size, opacity };
    board.elements.push(current); drawing=true; pushHistory(); draw(); return;
  }
  if(tool==='line' || tool==='rect'){
    current = { id:uid(tool), type:tool, x1:pt.x, y1:pt.y, x2:pt.x, y2:pt.y, color, size, opacity, fill: tool==='rect'?color:null };
    drawing=true; pushHistory(); draw(); return;
  }
  if(tool==='text'){
    spawnTextInput(e.offsetX, e.offsetY, '', txt =>{
      if(!txt) return; const wpt = screenToWorld(e.offsetX, e.offsetY);
      board.elements.push({ id:uid('txt'), type:'text', x:wpt.x, y:wpt.y, text:txt, color, size: Math.max(14, size*3/2), opacity });
      pushHistory(); draw();
    });
  }
});

canvas.addEventListener('pointermove', e=>{
  if(panActive){
    const dx = (e.clientX - panStart.x)/view.scale; const dy = (e.clientY - panStart.y)/view.scale;
    view.x = panStart.vx - dx; view.y = panStart.vy - dy; draw(); return;
  }
  if(!drawing || !current) return;
  const pt = screenToWorld(e.offsetX, e.offsetY);
  if(current.type==='stroke' || current.type==='highlight' || current.type==='eraser'){
    const last = current.points[current.points.length-1];
    const dist = Math.hypot(pt.x-last.x, pt.y-last.y);
    if(dist>0.8) current.points.push(pt);
  } else if(current.type==='line' || current.type==='rect'){
    current.x2 = pt.x; current.y2 = pt.y;
  }
  draw();
});

window.addEventListener('pointerup', ()=>{ drawing=false; current=null; panActive=false; });

// Space to pan
window.addEventListener('keydown', e=>{ if(e.code==='Space'){ spaceDown=true; updateStatus(); }});
window.addEventListener('keyup', e=>{ if(e.code==='Space'){ spaceDown=false; updateStatus(); }});

// ====== Floating text input ======
function spawnTextInput(sx, sy, initial, onDone){
  const input = document.createElement('textarea');
  input.className = 'floatingInput'; input.style.left = sx+'px'; input.style.top = sy+'px';
  input.value = initial || '';
  canvas.parentElement.appendChild(input); input.focus();
  const finish = (ok)=>{ const val = input.value; input.remove(); if(ok) onDone(val); };
  input.addEventListener('keydown', e=>{
    if((e.ctrlKey||e.metaKey) && e.key==='Enter'){ e.preventDefault(); finish(true); }
    if(e.key==='Escape'){ e.preventDefault(); finish(false); }
  });
  input.addEventListener('blur', ()=> finish(true));
}

// ====== UI Wiring ======
$('#toolSeg').addEventListener('click', e=>{ const b=e.target.closest('button[data-tool]'); if(!b) return; setTool(b.dataset.tool); });
$('#color').addEventListener('input', e=>{ color=e.target.value; updateStatus(); });
$('#size').addEventListener('input', e=>{ size=+e.target.value; updateStatus(); });
$('#opacity').addEventListener('input', e=>{ opacity=+e.target.value; updateStatus(); });
$('#zoom').addEventListener('input', e=>{ view.scale=+e.target.value; draw(); });
$('#resetView').addEventListener('click', ()=>{ view.x=0; view.y=0; view.scale=1; $('#zoom').value='1'; draw(); });
$('#bg').addEventListener('change', e=>{ board.bg=e.target.value; draw(); save(); });
$('#clearBoard').addEventListener('click', ()=>{ if(confirm('Clear the whiteboard?')){ board.elements=[]; pushHistory(); draw(); } });
$('#undoBtn').addEventListener('click', undo); $('#redoBtn').addEventListener('click', redo);

// keyboard shortcuts
window.addEventListener('keydown', e=>{
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); return; }
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='y'){ e.preventDefault(); redo(); return; }
  const map = { b:'brush', h:'highlighter', e:'eraser', l:'line', r:'rect', t:'text' };
  if(map[e.key]) setTool(map[e.key]);
});

// Insert Image
$('#importIMG').addEventListener('change', ()=>{
  const file = $('#importIMG').files?.[0]; if(!file) return; const r = new FileReader();
  r.onload = ()=>{ const img = new Image(); img.onload = ()=>{
      const w = Math.min(800, img.width), h = Math.round(img.height * (w/img.width));
      const cx = view.x + canvas.width/view.scale/2 - w/2; const cy = view.y + canvas.height/view.scale/2 - h/2;
      board.elements.push({ id:uid('img'), type:'image', x:cx, y:cy, w, h, dataURL:r.result });
      pushHistory(); draw();
    }; img.src = r.result; };
  r.readAsDataURL(file); $('#importIMG').value='';
});

// ====== Export / Import ======
$('#exportPNG').addEventListener('click', ()=>{
  canvas.toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='whiteboard.png'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),1000); }, 'image/png');
});

$('#exportSVG').addEventListener('click', ()=>{
  const w = canvas.width, h = canvas.height; let svg = `<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">`;
  const sc = v=>v*view.scale, X=x=> (x - view.x)*view.scale, Y=y=> (y - view.y)*view.scale;
  // background optional
  svg += `<rect width="100%" height="100%" fill="#0b1625"/>`;
  for(const el of board.elements){
    if(el.type==='stroke' || el.type==='highlight' || el.type==='eraser'){
      let d=''; el.points.forEach((p,i)=>{ d += (i? ' L':'M') + X(p.x)+','+Y(p.y); });
      const color = el.type==='eraser' ? 'white' : (el.color||'#fff');
      const opacity = el.type==='highlight' ? (el.opacity||0.3) : (el.opacity||1);
      const comp = el.type==='eraser' ? 'destination-out' : 'source-over';
      svg += `<path d="${d}" fill="none" stroke="${color}" stroke-linecap="round" stroke-linejoin="round" stroke-width="${sc(el.size)}" opacity="${opacity}" style="mix-blend-mode:${comp}" />`;
    }
    if(el.type==='line'){
      svg += `<line x1="${X(el.x1)}" y1="${Y(el.y1)}" x2="${X(el.x2)}" y2="${Y(el.y2)}" stroke="${el.color||'#fff'}" stroke-width="${sc(el.size)}" stroke-linecap="round"/>`;
    }
    if(el.type==='rect'){
      const x=Math.min(X(el.x1),X(el.x2)), y=Math.min(Y(el.y1),Y(el.y2));
      const w2=Math.abs(X(el.x2)-X(el.x1)), h2=Math.abs(Y(el.y2)-Y(el.y1));
      if(el.fill) svg += `<rect x="${x}" y="${y}" width="${w2}" height="${h2}" fill="${el.fill}" opacity="0.15"/>`;
      svg += `<rect x="${x}" y="${y}" width="${w2}" height="${h2}" fill="none" stroke="${el.color||'#fff'}" stroke-width="${sc(el.size)}"/>`;
    }
    if(el.type==='text'){
      const lines = (el.text||'').split(/\n/);
      lines.forEach((ln,i)=>{
        svg += `<text x="${X(el.x)}" y="${Y(el.y + i*(el.size*1.3))}" font-family="Inter,system-ui,sans-serif" font-size="${el.size}" fill="${el.color||'#fff'}">${escapeXml(ln)}</text>`;
      });
    }
    if(el.type==='image'){
      svg += `<image href="${el.dataURL}" x="${X(el.x)}" y="${Y(el.y)}" width="${sc(el.w)}" height="${sc(el.h)}" />`;
    }
  }
  svg += `</svg>`;
  const blob = new Blob([svg], {type:'image/svg+xml'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='whiteboard.svg'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),1000);
});

function escapeXml(s){ return s.replace(/[&<>\"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;'}[c])); }

$('#exportJSON').addEventListener('click', ()=>{
  const data = JSON.stringify({ bg:board.bg, elements:board.elements }, null, 2);
  const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([data], {type:'application/json'})); a.download='whiteboard.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),1000);
});

$('#importJSON').addEventListener('change', ()=>{
  const f = $('#importJSON').files?.[0]; if(!f) return; const r = new FileReader();
  r.onload = ()=>{ try{ const obj = JSON.parse(r.result); if(!obj.elements) throw new Error('Invalid whiteboard JSON'); board = { bg: obj.bg||'grid', elements: obj.elements }; imageCache.clear(); pushHistory(); draw(); } catch(e){ alert('Import error: '+e.message); } };
  r.readAsText(f); $('#importJSON').value='';
});

// ====== Status ======
function updateStatus(){ $('#status').textContent = `${tool[0].toUpperCase()+tool.slice(1)} ‚Ä¢ size ${size} ‚Ä¢ ${(opacity*100)|0}% ‚Ä¢ zoom ${view.scale.toFixed(2)}√ó${spaceDown?' ‚Ä¢ (Space: pan)':''}`; }

// ====== Init ======
(function init(){
  // restore bg
  $('#bg').value = board.bg || 'grid';
  resize();
  draw();
})();
</script>
</body>
</html>
